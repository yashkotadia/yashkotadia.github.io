{"version":3,"sources":["../../src/redux/nodes.ts"],"names":["getNodes","nodes","store","getState","Array","from","values","getNode","id","get","getNodesByType","type","nodesByType","getTypes","keys","hasNodeChanged","digest","node","internal","contentDigest","getNodeAndSavePathDependency","path","console","error","undefined","nodeId","saveResolvedNodes","nodeTypeNames","resolver","typeName","resolvedNodes","Map","resolved","set","dispatch","payload","key","getResolvedNode","resolvedNodesCache","__gatsby_resolved","addResolvedNodes","resolvedNodesFromCache","forEach","push","ensureIndexByTypedChain","cacheKey","chain","filtersCache","state","filterCache","length","addNodeToFilterCache","includes","valueOffset","v","i","nextProp","Set","add","ensureIndexByElemMatch","filter","addNodeToBucketWithElemMatch","valueAtCurrentStep","nestedQuery","isArray","elem","getFilterCacheByTypedChain","value","byTypedKey"],"mappings":"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","sourcesContent":["import { store } from \"./\"\nimport { IGatsbyNode } from \"./types\"\nimport { createPageDependency } from \"./actions/add-page-dependency\"\nimport { IDbQueryElemMatch } from \"../db/common/query\"\n\nexport type FilterCacheKey = string\nexport type FilterCache = Map<string | number | boolean, Set<IGatsbyNode>>\nexport type FiltersCache = Map<FilterCacheKey, FilterCache>\n\n/**\n * Get all nodes from redux store.\n */\nexport const getNodes = (): IGatsbyNode[] => {\n  const nodes = store.getState().nodes\n  if (nodes) {\n    return Array.from(nodes.values())\n  } else {\n    return []\n  }\n}\n\n/**\n * Get node by id from store.\n */\nexport const getNode = (id: string): IGatsbyNode | undefined =>\n  store.getState().nodes.get(id)\n\n/**\n * Get all nodes of type from redux store.\n */\nexport const getNodesByType = (type: string): IGatsbyNode[] => {\n  const nodes = store.getState().nodesByType.get(type)\n  if (nodes) {\n    return Array.from(nodes.values())\n  } else {\n    return []\n  }\n}\n\n/**\n * Get all type names from redux store.\n */\nexport const getTypes = (): string[] =>\n  Array.from(store.getState().nodesByType.keys())\n\n/**\n * Determine if node has changed.\n */\nexport const hasNodeChanged = (id: string, digest: string): boolean => {\n  const node = store.getState().nodes.get(id)\n  if (!node) {\n    return true\n  } else {\n    return node.internal.contentDigest !== digest\n  }\n}\n\n/**\n * Get node and save path dependency.\n */\nexport const getNodeAndSavePathDependency = (\n  id: string,\n  path: string\n): IGatsbyNode | undefined => {\n  const node = getNode(id)\n\n  if (!node) {\n    console.error(\n      `getNodeAndSavePathDependency failed for node id: ${id} as it was not found in cache`\n    )\n    return undefined\n  }\n\n  createPageDependency({ path, nodeId: id })\n  return node\n}\n\ntype Resolver = (node: IGatsbyNode) => Promise<any> // TODO\n\nexport const saveResolvedNodes = async (\n  nodeTypeNames: string[],\n  resolver: Resolver\n): Promise<void> => {\n  for (const typeName of nodeTypeNames) {\n    const nodes = store.getState().nodesByType.get(typeName)\n    if (!nodes) return\n\n    const resolvedNodes = new Map()\n    for (const node of nodes.values()) {\n      const resolved = await resolver(node)\n      resolvedNodes.set(node.id, resolved)\n    }\n    store.dispatch({\n      type: `SET_RESOLVED_NODES`,\n      payload: {\n        key: typeName,\n        nodes: resolvedNodes,\n      },\n    })\n  }\n}\n\n/**\n * Get node and save path dependency.\n */\nexport const getResolvedNode = (\n  typeName: string,\n  id: string\n): IGatsbyNode | null => {\n  const { nodesByType, resolvedNodesCache } = store.getState()\n  const nodes = nodesByType.get(typeName)\n\n  if (!nodes) {\n    return null\n  }\n\n  const node = nodes.get(id)\n\n  if (!node) {\n    return null\n  }\n\n  const resolvedNodes = resolvedNodesCache.get(typeName)\n\n  if (resolvedNodes) {\n    node.__gatsby_resolved = resolvedNodes.get(id)\n  }\n\n  return node\n}\n\nexport const addResolvedNodes = (\n  typeName: string,\n  resolvedNodes: IGatsbyNode[] = []\n): IGatsbyNode[] => {\n  const { nodesByType, resolvedNodesCache } = store.getState()\n  const nodes = nodesByType.get(typeName)\n\n  if (!nodes) {\n    return []\n  }\n\n  const resolvedNodesFromCache = resolvedNodesCache.get(typeName)\n\n  nodes.forEach(node => {\n    if (resolvedNodesFromCache) {\n      node.__gatsby_resolved = resolvedNodesFromCache.get(node.id)\n    }\n    resolvedNodes.push(node)\n  })\n\n  return resolvedNodes\n}\n\n/**\n * Given a (\"flat\") filter path leading up to \"eq\", a set of node types, and a\n * cache, create a cache that for each resulting value of the filter contains\n * all the Nodes in a Set (or, if the property is `id`, just the Nodes).\n * This cache is used for applying the filter and is a massive improvement over\n * looping over all the nodes, when the number of pages (/nodes) scale up.\n */\nexport const ensureIndexByTypedChain = (\n  cacheKey: FilterCacheKey,\n  chain: string[],\n  nodeTypeNames: string[],\n  filtersCache: FiltersCache\n): void => {\n  const state = store.getState()\n  const resolvedNodesCache = state.resolvedNodesCache\n\n  const filterCache: FilterCache = new Map()\n  filtersCache.set(cacheKey, filterCache)\n\n  // We cache the subsets of nodes by type, but only one type. So if searching\n  // through one node type we can prevent a search through all nodes, otherwise\n  // it's probably faster to loop through all nodes. Perhaps. Maybe.\n\n  if (nodeTypeNames.length === 1) {\n    getNodesByType(nodeTypeNames[0]).forEach(node => {\n      addNodeToFilterCache(node, chain, filterCache, resolvedNodesCache)\n    })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    state.nodes.forEach(node => {\n      if (!nodeTypeNames.includes(node.internal.type)) {\n        return\n      }\n\n      addNodeToFilterCache(node, chain, filterCache, resolvedNodesCache)\n    })\n  }\n}\n\nfunction addNodeToFilterCache(\n  node: IGatsbyNode,\n  chain: Array<string>,\n  filterCache: FilterCache,\n  resolvedNodesCache,\n  valueOffset: any = node\n): void {\n  // There can be a filter that targets `__gatsby_resolved` so fix that first\n  if (!node.__gatsby_resolved) {\n    const typeName = node.internal.type\n    const resolvedNodes = resolvedNodesCache.get(typeName)\n    node.__gatsby_resolved = resolvedNodes?.get(node.id)\n  }\n\n  // - for plain query, valueOffset === node\n  // - for elemMatch, valueOffset is sub-tree of the node to continue matching\n  let v = valueOffset as any\n  let i = 0\n  while (i < chain.length && v) {\n    const nextProp = chain[i++]\n    v = v[nextProp]\n  }\n\n  if (\n    (typeof v !== `string` &&\n      typeof v !== `number` &&\n      typeof v !== `boolean`) ||\n    i !== chain.length\n  ) {\n    // Not sure whether this is supposed to happen, but this means that either\n    // - The node chain ended with `undefined`, or\n    // - The node chain ended in something other than a primitive, or\n    // - A part in the chain in the object was not an object\n    return\n  }\n\n  let set = filterCache.get(v)\n  if (!set) {\n    set = new Set()\n    filterCache.set(v, set)\n  }\n  set.add(node)\n}\n\nexport const ensureIndexByElemMatch = (\n  cacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): void => {\n  // Given an elemMatch filter, generate the cache that contains all nodes that\n  // matches a given value for that sub-query\n\n  const state = store.getState()\n  const { resolvedNodesCache } = state\n\n  const filterCache: FilterCache = new Map()\n  filtersCache.set(cacheKey, filterCache)\n\n  if (nodeTypeNames.length === 1) {\n    getNodesByType(nodeTypeNames[0]).forEach(node => {\n      addNodeToBucketWithElemMatch(\n        node,\n        node,\n        filter,\n        filterCache,\n        resolvedNodesCache\n      )\n    })\n  } else {\n    // Expensive at scale\n    state.nodes.forEach(node => {\n      if (!nodeTypeNames.includes(node.internal.type)) {\n        return\n      }\n\n      addNodeToBucketWithElemMatch(\n        node,\n        node,\n        filter,\n        filterCache,\n        resolvedNodesCache\n      )\n    })\n  }\n}\n\nfunction addNodeToBucketWithElemMatch(\n  node: IGatsbyNode,\n  valueAtCurrentStep: any, // Arbitrary step on the path inside the node\n  filter: IDbQueryElemMatch,\n  filterCache: FilterCache,\n  resolvedNodesCache\n): void {\n  // There can be a filter that targets `__gatsby_resolved` so fix that first\n  if (!node.__gatsby_resolved) {\n    const typeName = node.internal.type\n    const resolvedNodes = resolvedNodesCache.get(typeName)\n    node.__gatsby_resolved = resolvedNodes?.get(node.id)\n  }\n\n  const { path, nestedQuery } = filter\n\n  // Find the value to apply elemMatch to\n  let i = 0\n  while (i < path.length && valueAtCurrentStep) {\n    const nextProp = path[i++]\n    valueAtCurrentStep = valueAtCurrentStep[nextProp]\n  }\n\n  if (path.length !== i) {\n    // Found undefined before the end of the path, so let Sift take over\n    return\n  }\n\n  // `v` should now be an elemMatch target, probably an array (but maybe not)\n\n  if (Array.isArray(valueAtCurrentStep)) {\n    // Note: We need to check all elements because the node may need to be added\n    // to multiple buckets (`{a:[{b:3},{b:4}]}`, for `a.elemMatch.b/eq` that\n    // node ends up in buckets for value 3 and 4. This may lead to duplicate\n    // work when elements resolve to the same value, but that can't be helped.\n    valueAtCurrentStep.forEach(elem => {\n      if (nestedQuery.type === `elemMatch`) {\n        addNodeToBucketWithElemMatch(\n          node,\n          elem,\n          nestedQuery,\n          filterCache,\n          resolvedNodesCache\n        )\n      } else {\n        // Now take same route as non-elemMatch filters would take\n        addNodeToFilterCache(\n          node,\n          nestedQuery.path,\n          filterCache,\n          resolvedNodesCache,\n          elem\n        )\n      }\n    })\n  }\n}\n\n/**\n * Given a (\"flat\") filter path leading up to \"eq\", a target value to filter\n * for, a set of node types, and a pre-generated lookup cache, return the set\n * of Nodes (or, if the property is `id` just the Node) which pass the filter.\n * This returns `undefined` if there is Node that passes the filter.\n *\n * Basically if the filter was {a: {b: {slug: {eq: \"foo/bar\"}}}} then it will\n * return all the nodes that have `node.slug === \"foo/bar\"`. That usually (but\n * not always) at most one node for slug, but this filter can apply to anything.\n *\n * The only exception is `id`, since internally there can be at most one node\n * per `id` so there's a minor optimization for that (no need for Sets).\n */\nexport const getFilterCacheByTypedChain = (\n  cacheKey: FilterCacheKey,\n  value: boolean | number | string,\n  filtersCache: FiltersCache\n): Set<IGatsbyNode> | undefined => {\n  const byTypedKey = filtersCache?.get(cacheKey)\n  return byTypedKey?.get(value)\n}\n"],"file":"nodes.js"}