"use strict";

exports.__esModule = true;
exports.getFilterCacheByTypedChain = exports.ensureIndexByElemMatch = exports.ensureIndexByTypedChain = exports.addResolvedNodes = exports.getResolvedNode = exports.saveResolvedNodes = exports.getNodeAndSavePathDependency = exports.hasNodeChanged = exports.getTypes = exports.getNodesByType = exports.getNode = exports.getNodes = void 0;

var _ = require("./");

var _addPageDependency = require("./actions/add-page-dependency");

/**
 * Get all nodes from redux store.
 */
const getNodes = () => {
  const nodes = _.store.getState().nodes;

  if (nodes) {
    return Array.from(nodes.values());
  } else {
    return [];
  }
};
/**
 * Get node by id from store.
 */


exports.getNodes = getNodes;

const getNode = id => _.store.getState().nodes.get(id);
/**
 * Get all nodes of type from redux store.
 */


exports.getNode = getNode;

const getNodesByType = type => {
  const nodes = _.store.getState().nodesByType.get(type);

  if (nodes) {
    return Array.from(nodes.values());
  } else {
    return [];
  }
};
/**
 * Get all type names from redux store.
 */


exports.getNodesByType = getNodesByType;

const getTypes = () => Array.from(_.store.getState().nodesByType.keys());
/**
 * Determine if node has changed.
 */


exports.getTypes = getTypes;

const hasNodeChanged = (id, digest) => {
  const node = _.store.getState().nodes.get(id);

  if (!node) {
    return true;
  } else {
    return node.internal.contentDigest !== digest;
  }
};
/**
 * Get node and save path dependency.
 */


exports.hasNodeChanged = hasNodeChanged;

const getNodeAndSavePathDependency = (id, path) => {
  const node = getNode(id);

  if (!node) {
    console.error(`getNodeAndSavePathDependency failed for node id: ${id} as it was not found in cache`);
    return undefined;
  }

  (0, _addPageDependency.createPageDependency)({
    path,
    nodeId: id
  });
  return node;
};

exports.getNodeAndSavePathDependency = getNodeAndSavePathDependency;

// TODO
const saveResolvedNodes = async (nodeTypeNames, resolver) => {
  for (const typeName of nodeTypeNames) {
    const nodes = _.store.getState().nodesByType.get(typeName);

    if (!nodes) return;
    const resolvedNodes = new Map();

    for (const node of nodes.values()) {
      const resolved = await resolver(node);
      resolvedNodes.set(node.id, resolved);
    }

    _.store.dispatch({
      type: `SET_RESOLVED_NODES`,
      payload: {
        key: typeName,
        nodes: resolvedNodes
      }
    });
  }
};
/**
 * Get node and save path dependency.
 */


exports.saveResolvedNodes = saveResolvedNodes;

const getResolvedNode = (typeName, id) => {
  const {
    nodesByType,
    resolvedNodesCache
  } = _.store.getState();

  const nodes = nodesByType.get(typeName);

  if (!nodes) {
    return null;
  }

  const node = nodes.get(id);

  if (!node) {
    return null;
  }

  const resolvedNodes = resolvedNodesCache.get(typeName);

  if (resolvedNodes) {
    node.__gatsby_resolved = resolvedNodes.get(id);
  }

  return node;
};

exports.getResolvedNode = getResolvedNode;

const addResolvedNodes = (typeName, resolvedNodes = []) => {
  const {
    nodesByType,
    resolvedNodesCache
  } = _.store.getState();

  const nodes = nodesByType.get(typeName);

  if (!nodes) {
    return [];
  }

  const resolvedNodesFromCache = resolvedNodesCache.get(typeName);
  nodes.forEach(node => {
    if (resolvedNodesFromCache) {
      node.__gatsby_resolved = resolvedNodesFromCache.get(node.id);
    }

    resolvedNodes.push(node);
  });
  return resolvedNodes;
};
/**
 * Given a ("flat") filter path leading up to "eq", a set of node types, and a
 * cache, create a cache that for each resulting value of the filter contains
 * all the Nodes in a Set (or, if the property is `id`, just the Nodes).
 * This cache is used for applying the filter and is a massive improvement over
 * looping over all the nodes, when the number of pages (/nodes) scale up.
 */


exports.addResolvedNodes = addResolvedNodes;

const ensureIndexByTypedChain = (cacheKey, chain, nodeTypeNames, filtersCache) => {
  const state = _.store.getState();

  const resolvedNodesCache = state.resolvedNodesCache;
  const filterCache = new Map();
  filtersCache.set(cacheKey, filterCache); // We cache the subsets of nodes by type, but only one type. So if searching
  // through one node type we can prevent a search through all nodes, otherwise
  // it's probably faster to loop through all nodes. Perhaps. Maybe.

  if (nodeTypeNames.length === 1) {
    getNodesByType(nodeTypeNames[0]).forEach(node => {
      addNodeToFilterCache(node, chain, filterCache, resolvedNodesCache);
    });
  } else {
    // Here we must first filter for the node type
    // This loop is expensive at scale (!)
    state.nodes.forEach(node => {
      if (!nodeTypeNames.includes(node.internal.type)) {
        return;
      }

      addNodeToFilterCache(node, chain, filterCache, resolvedNodesCache);
    });
  }
};

exports.ensureIndexByTypedChain = ensureIndexByTypedChain;

function addNodeToFilterCache(node, chain, filterCache, resolvedNodesCache, valueOffset = node) {
  // There can be a filter that targets `__gatsby_resolved` so fix that first
  if (!node.__gatsby_resolved) {
    const typeName = node.internal.type;
    const resolvedNodes = resolvedNodesCache.get(typeName);
    node.__gatsby_resolved = resolvedNodes === null || resolvedNodes === void 0 ? void 0 : resolvedNodes.get(node.id);
  } // - for plain query, valueOffset === node
  // - for elemMatch, valueOffset is sub-tree of the node to continue matching


  let v = valueOffset;
  let i = 0;

  while (i < chain.length && v) {
    const nextProp = chain[i++];
    v = v[nextProp];
  }

  if (typeof v !== `string` && typeof v !== `number` && typeof v !== `boolean` || i !== chain.length) {
    // Not sure whether this is supposed to happen, but this means that either
    // - The node chain ended with `undefined`, or
    // - The node chain ended in something other than a primitive, or
    // - A part in the chain in the object was not an object
    return;
  }

  let set = filterCache.get(v);

  if (!set) {
    set = new Set();
    filterCache.set(v, set);
  }

  set.add(node);
}

const ensureIndexByElemMatch = (cacheKey, filter, nodeTypeNames, filtersCache) => {
  // Given an elemMatch filter, generate the cache that contains all nodes that
  // matches a given value for that sub-query
  const state = _.store.getState();

  const {
    resolvedNodesCache
  } = state;
  const filterCache = new Map();
  filtersCache.set(cacheKey, filterCache);

  if (nodeTypeNames.length === 1) {
    getNodesByType(nodeTypeNames[0]).forEach(node => {
      addNodeToBucketWithElemMatch(node, node, filter, filterCache, resolvedNodesCache);
    });
  } else {
    // Expensive at scale
    state.nodes.forEach(node => {
      if (!nodeTypeNames.includes(node.internal.type)) {
        return;
      }

      addNodeToBucketWithElemMatch(node, node, filter, filterCache, resolvedNodesCache);
    });
  }
};

exports.ensureIndexByElemMatch = ensureIndexByElemMatch;

function addNodeToBucketWithElemMatch(node, valueAtCurrentStep, // Arbitrary step on the path inside the node
filter, filterCache, resolvedNodesCache) {
  // There can be a filter that targets `__gatsby_resolved` so fix that first
  if (!node.__gatsby_resolved) {
    const typeName = node.internal.type;
    const resolvedNodes = resolvedNodesCache.get(typeName);
    node.__gatsby_resolved = resolvedNodes === null || resolvedNodes === void 0 ? void 0 : resolvedNodes.get(node.id);
  }

  const {
    path,
    nestedQuery
  } = filter; // Find the value to apply elemMatch to

  let i = 0;

  while (i < path.length && valueAtCurrentStep) {
    const nextProp = path[i++];
    valueAtCurrentStep = valueAtCurrentStep[nextProp];
  }

  if (path.length !== i) {
    // Found undefined before the end of the path, so let Sift take over
    return;
  } // `v` should now be an elemMatch target, probably an array (but maybe not)


  if (Array.isArray(valueAtCurrentStep)) {
    // Note: We need to check all elements because the node may need to be added
    // to multiple buckets (`{a:[{b:3},{b:4}]}`, for `a.elemMatch.b/eq` that
    // node ends up in buckets for value 3 and 4. This may lead to duplicate
    // work when elements resolve to the same value, but that can't be helped.
    valueAtCurrentStep.forEach(elem => {
      if (nestedQuery.type === `elemMatch`) {
        addNodeToBucketWithElemMatch(node, elem, nestedQuery, filterCache, resolvedNodesCache);
      } else {
        // Now take same route as non-elemMatch filters would take
        addNodeToFilterCache(node, nestedQuery.path, filterCache, resolvedNodesCache, elem);
      }
    });
  }
}
/**
 * Given a ("flat") filter path leading up to "eq", a target value to filter
 * for, a set of node types, and a pre-generated lookup cache, return the set
 * of Nodes (or, if the property is `id` just the Node) which pass the filter.
 * This returns `undefined` if there is Node that passes the filter.
 *
 * Basically if the filter was {a: {b: {slug: {eq: "foo/bar"}}}} then it will
 * return all the nodes that have `node.slug === "foo/bar"`. That usually (but
 * not always) at most one node for slug, but this filter can apply to anything.
 *
 * The only exception is `id`, since internally there can be at most one node
 * per `id` so there's a minor optimization for that (no need for Sets).
 */


const getFilterCacheByTypedChain = (cacheKey, value, filtersCache) => {
  const byTypedKey = filtersCache === null || filtersCache === void 0 ? void 0 : filtersCache.get(cacheKey);
  return byTypedKey === null || byTypedKey === void 0 ? void 0 : byTypedKey.get(value);
};

exports.getFilterCacheByTypedChain = getFilterCacheByTypedChain;
//# sourceMappingURL=nodes.js.map